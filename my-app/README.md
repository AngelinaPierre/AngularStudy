# MyApp

This project was generated with [Angular CLI](https://github.com/angular/angular-cli) version 13.3.6.

## Development server

Run `ng serve` for a dev server. Navigate to `http://localhost:4200/`. The application will automatically reload if you change any of the source files.

## Code scaffolding

Run `ng generate component component-name` to generate a new component. You can also use `ng generate directive|pipe|service|class|guard|interface|enum|module`.

## Build

Run `ng build` to build the project. The build artifacts will be stored in the `dist/` directory.

## Running unit tests

Run `ng test` to execute the unit tests via [Karma](https://karma-runner.github.io).

## Running end-to-end tests

Run `ng e2e` to execute the end-to-end tests via a platform of your choice. To use this command, you need to first add a package that implements end-to-end testing capabilities.

## Further help

To get more help on the Angular CLI use `ng help` or go check out the [Angular CLI Overview and Command Reference](https://angular.io/cli) page.



===================== tutorial =====================

## Create a new workspace and an initial application

You develop applications in the context of an Angular workspace. A workspace contains the files for one or more projects. A project is the set of files that comprise an application or a library. For this tutorial, you will create a new workspace.

1. To create a new workspace and an initial application project:

2. Ensure that you are not already in an Angular workspace folder. For example, if you have previously created the Getting Started workspace, change to the parent of that folder.

Run the CLI command ng new and provide the name angular-tour-of-heroes, as shown here:

~~~
ng new angular-tour-of-heroes
~~~

3. The ng new command prompts you for information about features to include in the initial application project. Accept the defaults by pressing the Enter or Return key.

The Angular CLI installs the necessary Angular npm packages and other dependencies. This can take a few minutes.

It also creates the following workspace and starter project files:

- A new workspace, with a root folder named angular-tour-of-heroes
- An initial skeleton app project in the src/app subfolder
- Related configuration files

The initial app project contains a simple Welcome application, ready to run.

## Run the application

The Angular CLI includes a server, for you to build and serve your app locally.

1. Navigate to the workspace folder, such as my-app.

2. Run the following command:
   
~~~
cd angular-tour-of-heroes
ng serve --open
~~~

> The ng serve command builds the app, starts the development server, watches the source files, and rebuilds the application as you make changes to those files.
>
>The --open flag opens a browser to http://localhost:4200.

You should see the application running in your browser.


<br>

## `Angular Components`

- The page you see is the `application shell`. The shell is controlled by an Angular `component` named `AppComponent`.
- `Components`are the fundamental building blocks of Angular applications. 
- They display data on the screen, listen for user input, and take action based on that input.

<br>

## Make changes to the application
****
Open the project in your favorite editor or IDE and navigate to the src/app folder to make some changes to the starter application.

You'll find the implementation of the shell AppComponent distributed over three files:

1) `app.component.ts` : The component class code, written in TypeScript.
2) `app.component.html`: The component template, written in HTML.
3) `app.component.css`: The component's private CSS styles.

<br>

### `Change the application title`

<br>

- Open the component class file (app.component.ts) and change the value of the `title` property to 'Tour of Heroes'.

~~~
title = 'Tour of Heroes';
~~~

- Open the component template file (app.component.html) and delete the default template generated by the Angular CLI.
- Replace it with the following line of HTML.

~~~
<h1>{{title}}</h1>
~~~

- The double curly braces are Angular's `interpolation binding syntax`. This interpolation binding presents the component's `title` property value inside the HTML header tag.
- The browser refreshes and displays the new application title.


### `Add application styles`

<br>

Most apps strive for a consistent look across the application. The CLI generated an empty styles.css for this purpose. Put your application-wide styles there.

Open src/styles.css and add the code below to the file.

~~~
/* Application-wide Styles */
h1 {
  color: #369;
  font-family: Arial, Helvetica, sans-serif;
  font-size: 250%;
}
h2, h3 {
  color: #444;
  font-family: Arial, Helvetica, sans-serif;
  font-weight: lighter;
}
body {
  margin: 2em;
}
body, input[type="text"], button {
  color: #333;
  font-family: Cambria, Georgia, serif;
}
button {
  background-color: #eee;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  color: black;
  font-size: 1.2rem;
  padding: 1rem;
  margin-right: 1rem;
  margin-bottom: 1rem;
  margin-top: 1rem;
}
button:hover {
  background-color: black;
  color: white;
}
button:disabled {
  background-color: #eee;
  color: #aaa;
  cursor: auto;
}

/* everywhere else */
* {
  font-family: Arial, Helvetica, sans-serif;
}
~~~

<br>

### Summary

- You created the initial application structure using the Angular CLI
- You learned that Angular components display data
- You used the double curly braces of interpolation to display the application title


<br>
<hr> 

## `1 - The hero editor`

<br>

The application now has a basic title. Next you will create a new component to display hero information and place that component in the application shell.

<br>

### `Create the heroes component`
<br>

- Using the Angular CLI, generate a new component named heroes.

~~~
ng generate component heroes
~~~

The CLI creates a new folder, src/app/heroes/, and generates the three files of the HeroesComponent along with a test file.

The HeroesComponent class file is as follows:

~~~
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css']
})
export class HeroesComponent implements OnInit {

  constructor() { }

  ngOnInit(): void {
  }

}
~~~

You always import the Component symbol from the Angular core library and annotate the component class with @Component.

@Component is a decorator function that specifies the Angular metadata for the component.

The CLI generated three metadata properties:
- `selector`: The component's CSS element selector.
- `templateUrl`: The location of the component's template file.
- `styleUrls`: The location of the component's private CSS styles.


The CSS element selector, 'app-heroes', matches the name of the HTML element that identifies this component within a parent component's template.

The ngOnInit() is a lifecycle hook. Angular calls ngOnInit() shortly after creating a component. It's a good place to put initialization logic.

Always export the component class so you can import it elsewhere â€¦ like in the AppModule.


#### `Add a hero property`

<br>

Add a hero property to the HeroesComponent for a hero named "Windstorm".

~~~
hero = 'Windstorm';
~~~

<br>

#### `Show the hero`

<br>

Open the heroes.component.html template file. Delete the default text generated by the Angular CLI and replace it with a data binding to the new hero property.

~~~
<h2>{{hero}}</h2>
~~~

<br>

### `Show the HeroesComponent view`

<br>

To display the HeroesComponent, you must add it to the template of the shell AppComponent.

Remember that app-heroes is the element selector for the HeroesComponent. So add an <app-heroes> element to the AppComponent template file, just below the title.

~~~
<h1>{{title}}</h1>
<app-heroes></app-heroes>
~~~

Assuming that the CLI ng serve command is still running, the browser should refresh and display both the application title and the hero name.

<br>

### `Create a Hero interface`

<br>

A real hero is more than a name.

- Create a Hero interface in its own file in the src/app folder. Give it id and name properties.

~~~
[app/components/hero.ts]
export interface Hero {
  id: number;
  name: string;
}
~~~

- Refactor the component's hero property to be of type Hero. Initialize it with an id of 1 and the name Windstorm.

The revised HeroesComponent class file should look like this:

~~~
import { Component, OnInit } from '@angular/core';
import { Hero } from '../hero';

@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css']
})
export class HeroesComponent implements OnInit {
  hero: Hero = {
    id: 1,
    name: 'Windstorm'
  };

  constructor() { }

  ngOnInit(): void {
  }

}
~~~

> The page no longer displays properly because you changed the hero from a string to an object.


<br>

### `Show the hero object`

<br>

Update the binding in the template to announce the hero's name and show both id and name in a details layout like this:

~~~
<h2>{{hero.name}} Details</h2>
<div><span>id: </span>{{hero.id}}</div>
<div><span>name: </span>{{hero.name}}</div>
~~~

The browser refreshes and displays the hero's information.

<br>

### `Format with the UppercasePipe`

<br>

Modify the `hero.name` binding like this:

~~~
<h2>{{hero.name | uppercase}} Details</h2>
~~~

<br>

- The browser refreshes and now the hero's name is displayed in capital letters.
- The word `uppercase` in the interpolation binding, right after the pipe (`|`) character, activates the built-in `UppercasePipe`.
- [Pipes](https://angular.io/guide/pipes) are a good way to format strings, currency amounts, dates and other display data.
- Angular ships with several built-in pipes and you can create your own.


<br>

### Edit the hero

- Users should be able to edit the hero name in an `<input>` textbox.
- The textbox should both `display` the hero's `name` property and `update` that property as the user types.
- That means data flows from the component class `out to the screen` and from the screen `back to the class`.
- To automate that data flow, setup a two-way data binding between the `<input>` form element and the `hero.name` property.

<br>

#### `two-way binding`

<br>

- Refactor the details area in the `HeroesComponent` template so it looks like this:

~~~ 
<div>
  <label for="name">Hero name: </label>
  <input id="name" [(ngModel)]="hero.name" placeholder="name">
</div>
~~~

<br>

- `[(ngModule)]` : Is Angular's two-way data binding syntax.
- Here it binds the `hero.name` property to the HTML textbox so that data can flow in `both directions`: from the `hero.name` property to the textbox and from the textbox to the `hero.name`

<br>

#### `The missing FormsModule`

<br>

- Notice that the application stopped working when you added `[(ngModel)]`.
- To see the error, open the browser development tools and look in the console for a message like:

~~~
Template parse errors:
Can't bind to 'ngModel' since it isn't a known property of 'input'.
~~~

<br>

- Although `ngModel` is a valid Angular directive, it isn't available by default.
- It belongs to the optional `FormsModule` and you must opt-in to using it.


<br>

### AppModule

<br>

- Angular needs to know how the pieces of your application fit together and what other files and libraries the application requires. This information is called `metadata`.
- Some of the metadata is in the `@Component` decorators that you added to your component classes. 
- Other critical metadata is in `@NgModule` decorators.
- The mos important `@NgModule` decorator annotates the top-level `AppModule` class.
- The Angular CLI generated an `AppModule` class in `src/app/app.module.ts` when it created the project.
- There is where you opt-in to the `FormsModule`

<br>

#### `Import FormsModule`

<br>

- Open `AppModule` (app.module.ts) and import the `FormsModule` symbol from the `@angular/forms` library.

~~~
import { FormsModule } from '@angular/forms'; <-- NgModel lives here
~~~

<br>

- Then add `FormsModule` to the `@NgModule` metadata's `imports` arrya, which contains a list of external modules that the application needs.

~~~
[app.module.ts (#NgModule imports)]
imports: [
  BrowserModule,
  FormsModule
],
~~~

<br>

- When the browser refreshes, the application should work again. You can edit the hero's name and see the changes reflected immediately in the `<h2>` above the textbox.

<br>

### Declare HeroesComponent

<br>

- Every component must be declared in `exactly one` [NgModule](https://angular.io/guide/ngmodules).
- You didn't declare the `HeroesComponent`. So why did the application work?
- It worked because the Angular CLI declared `HeroesComponent` in the `AppModule` when it generated that component.
- Open `srx/app/app.module.ts` and find `HeroesComponent` imported near the top.

~~~
import { HeroesComponent } from './heroes/heroes.component';
~~~

<br>

- The `HeroesComponent` is declared in the `@NgModule.declarations` array.

~~~
[src/app/app.module.ts]
declarations: [
  AppComponent,
  HeroesComponent,
],
~~~

<br>

> `AppModule` declares both application components, `AppComponent` and `HeroesComponent`.


### `Summary`
- You used the CLI to create a second `HeroesComponent`
- You displayed the `HeroesComponent` by adding it to the `AppComponent` shell
- You applied the `UppercasePipe` to format the name.
- You used two-way data binding with the `ngModel` directive
- You leraned about the `AppModule`
- You imported the `FormsModule` in the `AppModule` so that Angular would recognize and apply the `ngModel` directive.
- You learned the importance of declaring components in the `AppModule` and appreciated that the CLI declared it for you.


<br>
<hr>

## `2 - Display a seleciton list`

<br>

- In this page, you'll expand the Tour of heroes application to display a list of heroes, and allow users to select a hero and display the hero's details.

<br>

### Create mock heroes

<br>

- You'll need some heroes to display.
- Eventually you'll get them from a remote data server. For now, you'll create some `mock heroes` and pretend they came from the server.
- Create a file called `mock-heroes.ts` in the `src/app/` folder. Define a `HEROES` constant as an array of ten heroes and export it. The file should look like this.

~~~
import { hero } from './hero'

export const HEROES: Hero[] = [
  { id: 12, name: 'Dr.nice' },
  { id: 13, name: 'Bombasto' },
  { id: 14, name: 'Celeritas' },
  { id: 15, name: 'Magneta' },
  { id: 16, name: 'RubberMan' },
  { id: 17, name: 'Dynama' },
  { id: 18, name: 'Dr. IQ' },
  { id: 19, name: 'Magma' },
  { id: 20, name: 'Tornado' }
]
~~~

<br>

### Display Heroes

<br>

- Open the `HeroesComponent` class file and import the mock `HEROES`.

~~~
import { HEROES } from '../mock-heroes'
~~~

<br>

- In the same file (`HeroesComponent` class), define a component property called `heroes` to expose the `HEROES` array for binding.

~~~
export class HeroesComponent implements OnInit {
  heroes = HEROES;
}
~~~

<br>

#### `List heroes with *ngFor`

<br>

Open the `HeroesComponent` template file and make the following changes:
1) Add an `<h2>` at the top
2) Below it add an HTML unordered list (`<ul>`) element.
3) Insert an `<li>` within the `<ul>`
4) Place a `<button>` inside the `<li>` that displays properties of a `hero` inside `<span>` elements.
5) Sprinkle some CSS classes for styling (you'll add the CSS styles shortly).

<br>

Make it look like this:

~~~
[heroes.component.html]

<h2> My Heroes </h2>
<ul class="heroes">
  <li>
    <button>
      <span class="badge>{{hero.id}}</span>
      <span class="name">{{hero.name}}</span>
    </button>
  </li>
</ul>
~~~

<br>

That displays an error since the property 'hero' does not exist. To have access to each individual hero and list them all, add an `*ngFor` to the `<li>` to iterate through the list of heroes:

~~~
<li *ngFor="let hero of heroes">
~~~
<br>

- The `*ngFor` is Angular's `repeater` directive. It repeats the host element for each element in a list.
- The syntax in this example is as follows:

`<li>` : The host element.
`heroes`: Holds the mock heroes list from the `HeroesComponent` class, the mock heroes list.
`hero`: Holds the current hero object for each iteration through the list.

> Don't forget the asterisk (*) character in front of `NgFor`. It's a critical part of the syntax.

<br>

After the browser refreshes, the list of heroes appears.

> `Interactive Elements`
> 
> NOTE: Inside the `<li>` element, wee've wrapped the hero's details in a `<button>` element. Later on we make the hero clickable, and it is better for accessibility purposes to use natively interactive HTML elements (e.g `<button>`) instead of addign event listeners to non-interactive ones (e.g. `<li>`).
> 
> For more details on accessibility, see [Accessibility in Angular](https://angular.io/guide/accessibility)

<br>

### `Style the heroes`

<br>

- The heroes list should be attractive and should respond visually when users hover over and select a hero from the list.
- In the [first tutorial](https://angular.io/tutorial/toh-pt0#app-wide-styles), you set the basic styles for the entire application in `styles.css`.
- That stylesheet didn't include styles for this list of heroes.
- You could add more styles to `styles.css` and keep growing that stylesheet as you add components.
- You may prefer instead to define private styles for a specific component and keep everything a component needs - the code, the HTML, and the CSS - together in one place.
- This approach makes it easier to re-use the component somewhere else and deliver the component's intended appearance even if the global styles are different.
- You define private styles either inline in the `@Component.styles` array or as stylesheet file(s) identified in the `@Component.styleUrls` array.
- When the CLI generated the `HeroesComponent`, it created an empty `heroes.component.css` stylesheet for the `HeroesComponent` and pointed to it in `@Component.styleUrls` like this.

~~~
[src/app/components/heroes/heroes.component.ts](@Component)

@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css']
})
~~~

<br>

- Open the `heroes.component.css` file and paste in the private CSS styles for the `HeroesComponent`. You'll find them in the [final code review](https://angular.io/tutorial/toh-pt2#final-code-review) at the bottom of this guide.

> Styles and stylesheets identified in `@Component` metadata are scoped to that specific component. The `heroes.component.css` styles apply only to the `HeroesComponent` and don't affect the outer HTML or the HTML in any other component.


<br>

### Viewing details

<br>

- When the user clicks a hero in the list, the component should display the selected hero's details at the bottom of the page.
- In this section, you'll listen for the hero item click event and display/update the hero details.

<br>

#### `Add a click event binding`

<br>

- Add a click event binding to the `<button>` in the `<li>` like this:

~~~
<li *ngFor="let hero of heroes">
  <button type="button" (click)="onSelect(hero)">
</li>
~~~

- This is an example of Angular's [event binding](https://angular.io/guide/event-binding) syntax.
- The parentheses around `click` tell Angular to listen for the `<button>` element's `click` event.
- When the user click in the `<button>`, Angular executes the `onSeleect(hero)` expression.
- In the next section, define an `onSelect()` method in `HeroesComponent` to display the hero that was defined in the `*ngFor` expression.

<br>

#### `Add the click event handler`

<br>

- Rename the component's `hero` property to `selectedHero` but don't assign any value to it since there is no `selected hero` when the application starts.
- Add the following `onSelect()` method, which assigns the clicked hero from the template to the component's `selectedHero`.

~~~
selectedHero?: Hero:
onSelect(hero: Hero): void {
  this.selectedHero = hero;
}
~~~

<br>

#### `Add a details section`

<br>

- Currently, you have a list in the component template.
- To click on a hero on the list and reveal details about that hero, you need a section for the detils to render in the template.
- Add the following to `heroes.component.html` beneath the list section:

~~~
<div *ngIf="selectedHero">
  <h2>{{selectedHero.name | uppercase}} Details</h2>
  <div>id: {{selectedHero.id}}</div>
  <div>
    <label for="hero-name">Hero name: </label>
    <input id="hero-name" [(ngModel)]="selectedHero.name" placeholder="name">
  </div>
</div>
~~~

<br>

- The hero details should only be displayed when a hero is selected.
- When a component is created initially, there is no selected hero, so we add the `*ngIf` directive to the `<div>` that wraps the hero details, to instruct Angular to render the section only when the `selectedHero` is actually defined (after it has been selected by clicking on a hero).

> Don't forget the asterisk (*) character in front of `ngIf`. It's a critical part of the syntax.

<br>

### Style the selected hero

<br>

- To help identify the selected hero, you can use the `.selected` CSS class in the [styles you added earlier](https://angular.io/tutorial/toh-pt2#styles).
- To apply the `.selected` class to the `<li>` when the user clicks it, use class binding.

![](./src/assets/Capturar1.PNG)

<br>

- Angular's [class binding](https://angular.io/guide/attribute-binding#class-binding) can add and remove a CSS class conditionally.
- Add `[class.some-css-class]="some-condition"` to the element you want to style.
- Add the following `[class.selected]` binding to the `<button>` in the `HeroesComponent` template:

~~~
[class.selected]="hero === selectedHero"
~~~

<br>

- When the current row hero is the same as the `selectedHero`, Angular adds the `selected`CSS class.
- When the two heroes are different, Angular removes the class.
- The finished `<li>` looks like this:

~~~
<li *ngFor="let hero of heroes">
  <button [class.selected]="hero === selectedHero" type="button" (click)>="onSelect(hero)">
    <span class="badge">{{hero.id}}</span>
    <span class="name">{{hero.name}}</span>
  </button>
</li>
~~~

<br>


### Summary

<br>

- The Tour of Heroes application displays a list of heroes with a detail view.
- The user can select a hero and see that hero's details.
- You used `*ngFor` to display a list
- You used `*ngIf` to conditionally include or exclude a block of HTML.
- You can toggle a CSS style class with a `class` binding.


<br>
<hr>

## `3 - Create a feature component`

<br>

- At the moment, the `HeroesComponent` displays both the list of heroes and the selected hero's details.
- Keeping all features in one component as the application grows will not be maintainable.
- You'll want to split up large components into smaller sub-components, each focused on a specific task or workflow.
- In this page, you'll take the first step in that direction by moving the hero details into a separate, reusable `HeroDetailComponent`.
- The `HeroesComponent` will only present the list of heroes.
- The `HeroDetailComponent` will present details of selected hero.

<br>

### Make the HeroDetailComponent

<br>

- Use the Angular CLI to generate the new component named `hero-detail`.

~~~
ng g component hero-detail
~~~

<br>

The command scaffolds the following:
- Creates a directory `src/app/components/hero-detail`

Inside the directory four files are generated:
- A CSS file for the component styles.
- An HTML file for the component template.
- A TypeScript file with a component class named `HeroDetailComponent`
- A test file for the `HeroDetailComponent` class.

The command also adds the `HeroDetailComponent` as a declaration in the `@NgMOdule` decorator of the `src/app/app.module.ts` file.


<br>

#### `Write the template`

<br>

- Cut the HTML for the hero detail from the bottom of the `HeroesCOmponent` template and paste it over the generated boilerplate in the `HeroDetailComponent` template.
- The pasted HTML refers to a `selectedHero`.
- The new `HeroDetailComponent` can present `any` hero, not just a selected hero.
- So replace "selectedHero" with "hero" everywhere in the template.
- When you're done, the `HeroDetailComponent`template should look like this:

~~~
<div *ngIf="hero">
  <h2>{{hero.name | uppercase}} Details</h2>
  <div><span>id: </span>{{hero.id}}</div>
  <div>
    <label for="hero-name">Hero name: </label>
    <input id="hero-name" [(ngModel)]="hero.name" placeholder="name">
  </div>
</div>
~~~


<br>

#### `Add the `@Input()` hero property`

<br>

- The `HeroDetailComponent` template binds to the component's `hero` property which is of type `Hero`.
- Open the `HeroDetailComponent` class file and import the `Hero` symbol.

~~~
import { Hero } from './src/app/interfaces/hero.ts'
~~~

- The `hero` property [must be an `Input` property](https://angular.io/guide/inputs-outputs), annotated with the `@Input()` decorator, because the `external HeroesComponent` [will bind to it](https://angular.io/tutorial/toh-pt3#heroes-component-template) like this:

~~~
<app-hero-detail [hero]="selectedHero"></app-hero-detail>
~~~

- Amend the `@angular/core` import statement to include the `Input` symbol.

~~~
import { Component, OnInit, Input } from '@angular/core';
~~~

- Add a `hero` property, preceded by the `@Input()` decorator.

~~~
@Input() hero?: Hero;
~~~

- That's the only change you should make to the `HeroDetailComponent` class.
- There are no more properties.
- There's no presentation logic.
- This component only receives a hero object through its `hero` property and displays it.


<br>

### Show the HeroDetailComponent

<br>

- The `HeroesComponent` used to display the hero details on its own, before you removed that portion of the tempalte.
- This section guides you through delegating logic to the `HeroDetailComponent`.
- The two components will have a parent/child relationship.
- The parent `HeroesComponent`will control the child `HeroDetailComponent` by sending it a new hero to display whenever the user selects a hero from the list.
- You won't change the `HeroesComponent` class but you will change its tempalte.

<br>

#### `Update the HeroesComponent template`

<br>

- The `HeroDetailComponent` selector is `'app-hero-detail'`.
- Add an `<app-hero-detail>` element near the bottom of the `HeroesComponent` template, where the hero detail view used to be.
- Bind the `HeroesComponent.selectedHero` to the element's `hero` property like this:

~~~
<app-hero-detail [hero]="selectedHero"></app-hero-detail>
~~~

- `[hero]="selectedHero"` is Angular [property binding](https://angular.io/guide/property-binding).
- It's a `one way` data binding from the `selectedHero` property of the `HeroesComponent` to the `hero` property of the target element, which maps to the `hero` property of the `HeroDetailComponent`.
- Now when the user clicks a hero in the list, the `selectedHero` changes.
- When the `selectedHero` changes, the `property binding` updates `hero` and the `HeroDetailComponent` displays the new hero.
- The revised `HeroesComponent` template should look like this:

~~~
<h2>My Heroes</h2>

<ul class="heroes">
  <li *ngFor="let hero of heroes">
    <button [class.selected]="hero === selectedHero" type="button" (click)="onSelect(hero)">
      <span class="badge">{{hero.id}}</span>
      <span class="name">{{hero.name}}</span>
    </button>
  </li>
</ul>

<app-hero-detail [hero]="selectedHero"></app-hero-detail>
~~~

- The browser refreshes and the application starts working again as it did before


<br>

### `What changed?`

<br>

- As [before](https://angular.io/tutorial/toh-pt2), whenever a user clicks on a hero name, the hero detail appears below the hero list. Now the `HeroDetailComponent` is presenting those details instead of the `HeroesComponent`.
- Refactoring the original `HeroesComponent` into two components yields benefits, both now and in the future:
    1) You reduced the `HeroesComponent` responsabilities.
    2) You can evolve the `HeroDetailComponent` into a rich hero editor without touching the parent `HeroesComponent`.
    3) You can evolve the `HeroesComponent` without touching the hero detail view.
    4) You can re-use the `HeroDetailComponent` in the template of some future component.


<br>

### `Summary`

- You created a separatem reusable `HeroDetailComponent`.
- You used a [property binding](https://angular.io/guide/property-binding) to give the parent `HeroesComponent`control over the child `HeroDetailComponent`.
- You used the [`@Input` decorator](https://angular.io/guide/property-binding) to make the `hero` property available for binding by the external `HeroesComponent`.

<br>
<hr>


## `4 - Add Services`

<br>

- The Tour of Heroes `HeroesComponent` is currently getting and displaying fake data.
- After the refactoring in this tutorial, `HeroesComponent` will be lean and focused on supporting the view.
- It will also be easier to unit-test with a mock service.

<br>
<hr>

### Why Services

<br>

- Components shouldn't fetch or save data directly and they certainly should'nt knowingly present fake data.
- They should focus on presenting data and delegate data access to a service.
- In this tutorial, you'll create a `HeroService`that all application classes can use to get heroes.
- Instead of creating that service with the `new` [keyword](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/new), you'll rely on Angular [dependency injection](https://angular.io/guide/dependency-injection) to inject it into the `HeroesComponent` constructor.
- Services are a great way to share information among classes that `don't know each other`.
- You'll create a `MessageService` and inject it in two places.
  -  Inject in `HeroService`, which uses the servicec to send a message.
  -  Inject in `MessagesComponent`, which displays that message, and also displays the ID when the user clicks a hero.

<br>
<hr>

### Create the HeroService

<br>

- Using the Angular CLI, create a service called hero.

~~~
ng g service hero
~~~

- The command generates a skeleton `HeroService` class in `/src/app/services/hero/hero.service.ts` as follows:

~~~
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class HeroService {
  constructor(){ }
}
~~~

#### [@Injectable()](https://angular.io/api/core/Injectable) `services`

<br>

- Notice that the new service imports the Angular `Injectable` symbol and annotates the class with the `@Injectable()` decorator.
- This marks the class as one that participates in the `dependency injection system`.
- The `HeroService` class is going to provide an injectable service and it can also have its own injected dependencies.
- It doesn't have any dependencies yet, but [it will soon](https://angular.io/tutorial/toh-pt4#inject-message-service)
- The `@Injectable()` decorator accepts a metadata object for the service, the same way the `@Component()` decorator did for your component class.

<br>

#### `Get Hero data`

<br>

- The `HeroService` could het hero data from anywhere - a web service, local storage, or a mock data source.
- Removing data access from components means you can change your mind about the implementation anytime, without touching any components.
- They don't know how the service works.
- The implementation in this tutorial will continue to deliver mock heroes.
- Import the `Hero` and `HEROES`

~~~
[/src/app/services/hero/hero.service.ts]
import { HEROES } from './src/app/interfaces/mock-heroes'
import { Hero } from './src/app/interfaces/hero
~~~

- Add the `getHeroes` method to return the `mock heroes`

~~~
getHeroes(): Hero[] {
  return HEROES;
}
~~~

<br>

<hr>

### Provide the HeroService

<br>

- You must make the `HeroService` available to the dependency injection system before Angular can `Inject` it into the `HeroesComponent` by registering a `provider`.
- A provider is something that can create or deliver a service; in this case, it instantiates the `HeroService` class to provide the service.
- To make sure that the `HeroService` can provide this service, register it with the `injector`, which is the object that is responsible for choosing and injecting the provider where the application requires it.
- By default, the Angular CLI command `ng generate service` registers a provider woth the `root injector` for your service by including provider metadata, that is `providedIn: 'root' ` in the `@Injectable()` decorator.

~~~
@Injectable({
  providedIn: 'root',
})
~~~

- When you provide the service at the root level, Angular creates a single, shared instance of `HeroService` and injects into any class that asks for it.
- Registering the provider in the `@Injectable` metadata also allows Angular to optmize an application by removing the service if it turns out not to be used after all.

> To learn more about providers, see the [Providers section](https://angular.io/guide/providers). To learn more about injectors, see the [Dependency Injection guide](https://angular.io/guide/dependency-injection).

- The `HeroService` is now ready to plug into the `HeroesComponent`.

> This is an interim code sample that will allow you to provide and use the `HeroService`. At this point, the code will differ from the `HeroService` in the ["final code review"](https://angular.io/tutorial/toh-pt4#final-code-review).

<br>
<hr>

### Update HeroesComponent

<br>

- Open the `HeroesComponent`class file.
- Delete the `HEROES` import, because you won't need that anymore.
- Import the `HeroService`instead.

~~~
import { HeroService } from './src/app/services/hero/hero.service.ts
~~~

- Replace the definition of the `heroes` property with a declaration.

~~~
heroes: Hero[] = [];
~~~

<br>

### Inject the HeroService

<br>

- Add a private `heroService` parameter of type `HeroService` to the constructor.

~~~
constructor(
  private heroService: HeroService
) {}
~~~

- The parameter simultaneously defines a private `HeroService` property and identifies it as a `HeroService` injection site.
- When Angular creates a `HeroesComponent`, the [Dependency Injection](https://angular.io/guide/dependency-injection) system sets the `heroService` parameter to the singleton instance of `HeroService`.


<br>

### Add getHeroes()

- Create a method to retrive the heroes from the service.

~~~
getHeroes(): void {
  this.heroes = this.heroService.getHeroes();
}
~~~

<br>

### Call it in ngOnInit()

<br>

- While you could call `getHeroes()` in the constructor, that's not the best practice.
- Reserve the constructor for minimal initialization such as wiring constructor parameters to properties.
- The constructor shouldn't do `anything`.
- It certainly shouldn't call a function that makes HTTP requests to a remote server as a `real` data service would.
- Instead, call `getHeroes()` inside the [ngOnInit lifecycle hook](https://angular.io/guide/lifecycle-hooks) and let Angular call `ngOnInit()` at an appropriate time `after` constructing a `HeroesComponent` instance.

~~~
ngOnInit(): void {
  this.getHeroes();
}
~~~

<br>

### See it run

After the browser refreshes, the application should run as before, showing a list of heroes and a hero detail view when you click on a hero name.

<br>
<hr>

### Observable data

<br>

- The `HeroesService.getHeroes()` method has a `synchronous singnature`, which implies that the `HeroService` can fetch heroes synchronously.
- The `heroesComponent` consumes the `getHeroes()` result as if heroes could be fetched synchronously.

~~~
this.heroes = this.heroService.getHeroes();
~~~

- This will not work in a real application.
- You're getting away with it now because the service currently returns `mock heroes`.
- But soon the application will fetch heroes from a remote server, which is an inherently `asynchronous` operation.
- The `HeroService` must wait for the server to respond, `getHeroes()` cannot return immediately with hero data, and the browser will not block while the service waits.
- `HeroService.getHeroes()` must have an `asynchronous signature` of some kind.
- In this tutorial, `HeroService.getHeroes()` will return an `Observable` because it will eventually use the Angular `HttpClient.get` method fetch the heroes and 
[`HttpClient.get()` returns an `Observable`](https://angular.io/guide/http).

<br>

#### `Observable HeroService`

<br>

- `Observable` is one of the key classes in the [RxJS library](https://rxjs.dev/).
- In a [later tutorial on HTTP](https://angular.io/tutorial/toh-pt6), you'll learn that Angular's `HttpClient` methods return RxJS `Observable`s.
- In this tutorial, you'll simulate getting data from the server with the RxJS `of()` function.
- Open the `HeroService` file and import the `Observable` and `of` symbols from RxJS.

~~~
import { Observable, of } from 'rxjs';
~~~

- Replace the `getHeroes()` method with the following:

~~~
getHeroes(): Observable<Hero[]>{
  const heroes = of(HEROES);
  return heroes;
}
~~~

- `of(HEROES)` returns an `Observable<Hero[]>` that emits a `single value`, the array of mock heroes.


> IN the [HTTP tutorial](https://angular.io/tutorial/toh-pt6), you'll call `HttpClient.get<Hero[]>()` which also returns an `Observable<Hero[]>` that wmits a `single value`, an array of heroes from the body of the HTTP response.

<br>

#### `Subscribe in HeroesComponent`

<br>

- The `HeroService.getHeroes` method used to return a `Hero[]`.
- Now it returns an `Observable<Hero[]>`.
- You'll have to adjust to that difference in `HeroesComponent`.
- Find the `getHeroes` method and replace it with the following code (shown side-by-side with the previous version for comparison).

~~~
[hero.component.ts]

getHeroes(): void {
  this.heroService.getHeroes()
    .subscribe(heroes => this.heroes = heroes);
}
~~~

- `Observable.subscribe()` is the critical difference.
- The previous version assigns an array of heroes to the component's `heroes` property.
- The assignment occurs `synchronously`, as if the server could return heroes instantly or the browser could freeze the UI whie it waited for the server's response.
- That won't work when the `HeroService` is actually making requests of a remote server.
- The new version waits for the `Observable` to emit the array of heroes - which could happen now or several minutes from now.
- The `subscribe()` method passes the emitted array to the callback, which sets the component's `heroes` property.
- This asynchronous approach will work when the `HeroService` requests heroes from the server.

<br>
<hr>

### Show messages

<br>

This section guides you through the following:
- Adding a `MessageComponent` that displays application messages at the bottom of the screen.
- Creating an injectable, app-wide `MessageService` for sending messages to be displayed.
- Injecting `MessageService` into the `HeroService`
- Displaying a message when `HeroService` fetches heroes successfully.
  
<br>

#### `Create MessagesComponent`

<br>

- Use the CLI to create the MessageComponent.

~~~
ng g component messages
~~~

- The CLI creates the component files in the `/src/app/component/messages` folder and declares the `MessagesComponent` in `AppModule`.
- Modify the `AppComponent` tempalte to display the generated `MessagesComponent`.

~~~
<h1>{{title}}</h1>
<app-heroes></app-heroes>
<app-messages></app-messages>
~~~

- You should see the default paragraph from `MessagesComponent` at the bottom of the page.

<br>

#### `Create the MessageService`

<br>

- Use the CLI to create the `MessageService` in `/src/app`.

~~~
ng g service message
~~~

- Open `MessageService` and replace its content with the following:

~~~
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})

export class MessageService {
  messages: string[] = [];

  add(message: string) {
    this.message.push(message);
  }

  clear() {
    this.messages = [];
  }
}
~~~

- The service exposes its cache of `messages` and two methods: 
  - One to `add()` a message to the cache.
  - Antoher to `clear()` the cache.

<br>

#### `Inject it into the HeroService`

<br>

In `heroService` import the `MessageService`.

~~~
import { MessageService } from './message.service';
~~~

- Modify the constructor with a parameter that declares a private `messageService` property.
- Angular will inject the singleton `MessageService` into that property when it creates the HeroService.

~~~
constructor(
  private messageService: MessageService
){}
~~~

> this is a typical "service-in-service" scenario. You inject the `MessageService` into the `HeroService` which is injected into the `HeroesComponent`.

<br>

#### `Send a message from the HeroService`

<br>

- Modify the `getHeroes()` method to send a message when the heroes are fetched.

~~~
[hero.service.ts]

getHeroes(): Observable<Hero[]> {
  constheroes = of(HEROES);
  this.messageService.add('HeroService: fetched Heroes');
  return heroes;
}
~~~

<br>

#### `Display the message from the HeroService`

<br>

- The `MessaagesComponent` should display all messages, including the message sent by the `HeroService` when it fetches heroes.
- Open `MessagesComponents` and import the `MessageService`

~~~
import { MessageService } from './src/app/services/message/message.service.ts'
~~~

- Modify the constructor with a parameter that declares a `public messageService` property.
- Angular will inject the singleton `MessageService` into that property when it creates the `MessageComponent`.

~~~
[messages.component.ts]

constructor(
  public messageService: MessageService
){ }
~~~

- The `messageService` property must be `public` because you're going to bind to it in the template.

> Angular only binds to `public` component properties.

<br>

#### `Bind to the MessageService`

<br>

- Replace the CLI-generated `MessagesComponent` template with the following:

~~~
<div *ngIf="messageService.messages.length">

  <h2>Messages</h2>

  <button 
    type="button" 
    class="clear" 
    (click)="messageService.clear()"
  >Clear messages</button>

  <div *ngFor='let message of messageService.messages'>{{message}}</div>
</div>
~~~

<br>

- This template binds directly to the component's `messageService`.

![](./src/assets/Capturar2.PNG)

<br>

- The messages will look better when you add the private CSS styles to `messages.component.css` as listed in one of the ["final code review"](https://angular.io/tutorial/toh-pt4#final-code-review) tabs below.

<br>
<hr>

### Add additional messages to hero service

<br>

- The following example shows how to send and display a message each time the user clicks on a hero, showing a history of the user's selections.
- This will be helpful when you get the next section on [Routing](https://angular.io/tutorial/toh-pt5).

~~~
[hero.component.ts]

import { Component, OnInit } from '@angular/core';

import { Hero } from './src/app/interfaces/hero.ts;
import { HeroService } from './src/app/services/hero/hero.service.ts';
import { MessageService } from './src/app/services/message/message.service.ts';

@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css'],
})

export class HeroesComponent implements OnInit {

  selectedHero?: Hero;

  heroes: Hero[] = [];

  constructor(
    private heroService: HeroService,
    private messageService: MessageService,
  ){}

  ngOnInit(): void {
    this.getHeroes();
  }

  onSelect(hero: Hero): void {
    this.selectedHero = hero;
    this.messageService.add(`HeroesComponent: Selected hero id=${hero.id}`);
  }

  getHeroes(): void {
    this.heroService.getHeroes()
      .subscribe(heroes => this.heroes = heroes);
  }
}
~~~

<br>
<hr>
 
 ### Summary

 <br>

 - You refactored data access to the `HeroService` class.
 - You registered the `HeroService` as the `provider` of its service at the root level so that it can be injected anywhere in the application.
 - You used [Angular Dependency Injection](https://angular.io/guide/dependency-injection) to inject it into a component.
 - You gave the `HeroService get data` method an asynchronous signature.
 - You discovered `Observable` and the RxJS `Observable` library.
 - You used RxJS `of()` to return an observable of mock heroes (`Observable<Her[]>`).
 - The component's `ngOnInit` lifecycle hook calls the `heroService` method, not the constructor.
 - You created a `MessageService` for loosely-coupled communication between classes.
 - The `HeroService` injected into a component is created with another injected service, `MessageService`.

<br>
<hr>

## `5 - Add Navigation`

<br>

- There are new requirements for the Tour of Heroes app:
  - Add a `Dashboard` view.
  - Add the ability to navigate between the `Heroes` and `Dashboard` views.
  - When the user click a hero name in either view, navigate to a detail view of the selected hero.
  - When the users click a `deep link` in an email, open the detail view for a particular hero.
- When you're done, users will be able to navigate the application like this:

![](./src/assets/Capturar3.PNG)

<br>
<hr>

### Add the AppRoutingModule

<br>

- In Angular, the best practice is to load and configure the router in a separate, top-level module that is dedicated to routing and imported by the root `AppModule`.
- By convetion, the module class name is `AppRoutingModule` and it belongs in the `app-routing.module.ts` in the `/src/app` folder.
- Use the CLI to generate it:

~~~
ng g module app-routing --flat --module-app
~~~

![](./src/assets/Capturar4.PNG)

<br>

- The generated file looks like this:

~~~
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: []
})
export class AppRoutingModule {}
~~~

- Replace it with the following:

~~~
import { NgModule } from '@angular/core';
import { RouterModule, Router } from '@angular/router';
import { HeroesComponent } from './src/app/components/heroes/heroes.component.ts'

const router: Router = [
  {
    path: 'heroes', 
    component: HeroesComponent,
  },
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
})
export class AppRoutingModule {}
~~~

- First, the `app-routing.module.ts` file imports [RouterModule](https://angular.io/api/router/RouterModule) and [Routes](https://angular.io/api/router/Routes) so the application can have routing functionality.
- The next import, `HeroesComponent`, will give the Router somewhere to go once you configure the routes.
- Notice that the [CommonModule](https://angular.io/api/common/CommonModule) references and `declarations` array are unnecessary, so are no longer part of `AppRoutingModule`.
- THe following sections explain the rest of the `AppRoutingModule` in more detail.

<br>

#### `Routes`

<br>

- The next part of the file is where you configure your routes.
- `Routes` tell the Router which view to display when a user clicks a link or pastes a URL into the browser address bar.
- Since `app-routing.module.ts` already imports `HeroesComponent`, you can use it in the `routes` array:

~~~
const routes: Routes = [
  {
    path: 'heroes',
    component: HeroesComponent,
  }
];
~~~

- A typical Angular [Route](https://angular.io/api/router/Route) has two properties:

![](./src/assets/Capturar5.PNG)

<br>

- This tells the router to match that URL to `path: 'heroes'` and display the `HeroesComponent`when the URL is something like `localhost:4200/heroes`.

<br>

#### [`RouterModule.forRoot()`](https://angular.io/api/router/RouterModule#forRoot)

<br>

- The [@NgModeule](https://angular.io/api/core/NgModule) metadata initializes the router and starts it listening for browser location changes.
- The following line adds the [RouterModule](https://angular.io/api/router/RouterModule) tot he `AppRoutingModule` imports array and configures it with the `routes` in one step by calling [RouterModule.forRoot()](https://angular.io/api/router/RouterModule#forRoot):

~~~
imports: [RouterModule.forRoot(routes)],
~~~

> The method is called `forRoot()` because you configure the router at the application's root level. The `forRoot()` method supplies the service providers and directives needed for routing, and performs the initial navigation based on the current browser URL.

<br>

- Next, `AppRoutingModule` exports [RouterModule](https://angular.io/api/router/RouterModule) so it will be available throughout the application.

~~~
exports: [RouterModule]
~~~

<br>
<hr>

### Add [RouterOutlet](https://angular.io/api/router/RouterOutlet)

<br>
- Open the `AppComponent` template and replace the `<app-heroes>` element with a [<router-outlet>](https://angular.io/api/router/RouterOutlet) element.

~~~
<h1> {{title}}</h1>
<router-outlet></router-outlet>
<app-messages></app-messages>
~~~

- The `AppComponent` template no longer needs `<app-heroes>` because the application will only display the `HeroesComponent` when the user navigates to it.
- The `<router-outlet>` tells the router where to display routed views.

> The [RouterOutlet](https://angular.io/api/router/RouterOutlet) is one of the router directives that became available to the `AppComponent` because `AppModule` imports `AppRoutingModule` which exported [RouterModule](https://angular.io/api/router/RouterModule). The `ng generate` command you ran at the start of this tutorial added this import because of the `--module=app` flag. If you manually created `app-routing.module.ts` or used a tool other than the CLI to do so, you'll need to import `AppRoutingModule` into `app.module.ts` and add it to the `imports`array of the [NgModule](https://angular.io/api/core/NgModule)

<br>

##### Try it

<br>

- You should still be running with this CLI command:
~~~
ng serve
~~~

- The browser should refresh and display the application title but not the list of heroes.
- Look at the browser's address bar. The URL ends in `/`. The route path to `HeroesComponent` is `/heroes`.
- Append `/heroes` to the URL in the browser address bar. You should see the familiar heroes master/detail view.
- Remove `/heroes` from the URL in the browser address bar. 
- The browser should refresh and diosplay the application title but not the list of heroes.


<br>
<hr>

### Add a navigation link ([routerLink](https://angular.io/api/router/RouterLink))

<br>

- Ideally, users should be able to click a link to navigate rather than pasting a route URL into the address bar.
- Add a `<nav>` element and, within that, an anchor element that, when clicked, triggers navigation to the `HeroesComponent`.
- The revised `AppComponent` template looks like this:

~~~
<h1>{{title}}</h1>
<nav>
  <a routerLink="/heroes">Heroes</a>
</nav>
<router-outlet></router-outlet>
<app-messages></app-messages>
~~~

- A [`routerLink` attribute](https://angular.io/tutorial/toh-pt5#routerlink) is set to `"/heroes"`, the string that the router matches to the route to `heroesComponent`.
- The [`routerLink`](https://angular.io/api/router/RouterLink) is the selector for the [`RouterLink` directive](https://angular.io/api/router/RouterLink) that turns user click into router navigations.
- It's another of the public directives in the [`RouterModule`].
- The browser refreshes and displays the application title and heroes link, but not the heroes list.
- Click the link. The address bar updates to `/heroes` and the list of heroes appears.

> Make this and future navigation links look better by adding private CSS styles to `app.component.css` as listed in the [final code review](https://angular.io/tutorial/toh-pt5#appcomponent) below.

<br>
<hr>

### Add a dashboard view

<br>

- Routing makes more sense when there are multiple views.
- So far there's only the heroes view.
- Add a `DashboardComponent` using the CLI:

~~~
ng g component dashboard
~~~

- The CLI generates the files for the `DashboardComponent` and declares it in `AppModule`.
- Replace the default file content in these three files as follows:

~~~
[dashboard.component.html]
<h2>Top Heroes</h2>
<div class="heroes-menu">
  <a *ngFor="let hero of heroes">{{hero.name}}</a>
</div>
~~~

~~~
[dashboard.component.ts]

import { Component, Oninit } from '@angular/core';
import { Hero } from './src/app/interfaces/hero.ts';
import { HeroService } from './src/app/services/hero/hero.service.ts';

@Component({
  selector: 'app-dashboard',
  templateUrl: './dashboard.component.html',
  styleUrl: ['./dashboard.component.css' ]
})
export class DashboardComponent implements OnInit {
  heroes: Hero[] = [];

  constructor(
    private heroService: HeroService
  ){ }

  ngOnInit(): void {
    this.getHeroes();
  }

  getHeroes(): void {
    this.heroService.getHeroes()
      .subscribe(heroes => this.heroes = heroes.slice(1, 5));
  }
}
~~~

~~~
[dashboad.component.css]
/* DashboardComponent's private CSS styles */

h2 {
  text-align: center;
}

.heroes-menu {
  padding: 0;
  margin: auto;
  max-width: 1000px;

  /* flexbox */
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: space-around;
  align-content: flex-start;
  align-items: flex-start;
}

a {
  background-color: #3f525c;
  border-radius: 2px;
  padding: 1rem;
  font-size: 1.2rem;
  text-decoration: none;
  display: inline-block;
  color: #fff;
  text-align: center;
  width: 100%;
  min-width: 70px;
  margin: .5rem auto;
  box-sizing: border-box;

  /* flexbox */
  order: 0;
  flex: 0 1 auto;
  align-self: auto;
}

@media (min-width: 600px) {
  a {
    width: 18%;
    box-sizing: content-box;
  }
}

a:hover {
  background-color: #000;
}

~~~

<br>

The `template` presents a grid of hero name links.
- The [*ngFor]() repeater creates as many links as are in the component's `heroes`array.
- The links are styleed as colored blocks by the `dashboard.component.css`.
- The links don't go anywhere yet but [they will shortly](https://angular.io/tutorial/toh-pt5#hero-details).

The `class` is similar to the `HeroesComponent` class.
- It defines a `heroes` array property.
- The constructor expects Angular to inject the `HeroService` into a private `heroService` property.
- The `ngOnInit()` lifecycle hook calls `getHeroes()`.

This `getHeroes()` returns the sliced list of heroes at positions 1 and 5, returning only four of the Top Heroes (2nd, 3nd, 4th, and 5th).

~~~
getHeroes(): void {
  this.heroService.getHeroes()
    .subscribe(heroes => this.heroes = heroes.slice(1, 5));
}
~~~

<br>

#### `Add the dashboard route`

<br>

- To navigate to the dashboard, the router needs an appropriate route.
- Import the `DashboardComponent` in the `app-routing-module.ts` file.

~~~
[app-routing.module.ts]

import { DashboardComponent} from './src/app/components/dashboard/dashboard/
~~~

- Add a route to the `routes` array that matches a path to the `DashboardComponent`.

~~~
{
  path: 'dashboard',
  component: DashboardComponent,
},
~~~

<br>

#### `Add a default route`

<br>

- When the application starts, the browser's address bar points to the web site's root.
- That doesn't match any existing route so the router doesn't navigate anywhere.
- The space below the [<router-outlet>](https://angular.io/api/router/RouterOutlet) is blank.
- To make the application navigate to the dashboard automatically, add the following route to the `routes` array.

~~~
[app-routing.module.ts]

{path: '', redirecTo: '/dashboard', pathMatch: 'full'},
~~~

- This route redirects a URL that fully matches the empty path to the route whose path is `'/dashboard'`.
- After the browser refreshes, the router loads the `DashboardComponent` and the browser address bar shows the `/dashboard` URL.

<br>

#### `Add dashboard link to the shell`

<br>

- The user should be able to navigate back and forth between the `DashboardComponent` and the `HeroesComponent` by clicking links in the navigation area near the top of the page.
- Add a dashboard navigation link to the `AppComponent` shell template, just above the `Heroes link`.

~~~
[app.component.html]

<nav>
  <a routerLink="/dashboard">Dashboard</a>
  <a routerLink="/heroes">Heroes</a>
</nav>
<router-outlet></router-outlet>
<app-messages></app-messages>
~~~

- After the browser refreshes you can navigate freely between the two views by clicking the links.

<br>
<hr>

### Navigate to hero details

<br>

- The `HeroDetailComponent` displays details of a selected hero.
- At the moment the `HeroDetailComponent`is only visible at the bottom of the `HeroComponent`.

The user should be able to get to these details in three ways:
1) By clicking a hero in the dashboard.
2) By clicking a hero in the heroes list.
3) By pasting a "deep link" URL into the browser address bar that identifies the hero to display.

- In this section, you'll enable navigation to the `HeroDetailComponent`and liberate it from the `HeroesComponent`.

<br>

#### `Delete hero detail from the HeroesComponent`

<br>

- When the user clicks a hero item in the `HeroesComponent`, the application should navigate to the `HeroDetailComponent`, replacing the heroes list view with the hero detail view.
- The heroes list view should no longer show hero detail as it does now.
- Open th `HeroesComponent` template (`heroes/heroes.component.html`) and delete the `<app-hero-detail>` element from the bottom.
- Clicking a hero item now does nothing. 
- You'll [fix that shortly](https://angular.io/tutorial/toh-pt5#heroes-component-links) after you enable routing the `HeroDetailComponent`.

<br>

#### `Add a hero detail route`

<br>

- A URL like `~/detail/11` would be a good URL for navigating to the `Hero Detail` view of the hero whose `id` is `11`.
- Open `app-routing.module.ts` and `import` `HeroDetailComponent`.

~~~
import { HeroDetailComponent } from './src/app/components/hero-detail/hero-detail.component.ts';
~~~

- Then add a `parameterized route` to the `routes` array that matches the path pattern to the `hero details` view.

~~~
{ path: 'detail/:id', component: HeroDetailComponent },
~~~

<br>

- The colon (`:`) character in the `path` indicates that `:id` is a placeholder for a specific hero `id`.
- At this point, all application routes are in place.

~~~
[app-routing.module.ts]

const routes: Routes = [
  { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
  { path: 'dashboard', component: DashboardComponent },
  { path: 'detail/:id', component: HeroDetailComponent },
  { path: 'heroes', component: HeroesComponent }
];
~~~

#### Â´DashboardComponent hero linksÂ´

<br>

- The `DashboardComponent` hero links do nothing at the moment.
- Now that the router has a route to `HeroDetailComponent`, fix the dashboard hero links to navigate using the `parameterized` dashboard route.

~~~
[dashboard.component.html]

<a 
  *ngFor="let hero of heroes" 
  routerLink="/detail/{{hero.id}}"
>{{hero.name}}</a>
~~~

- You're using Angular [interpolation binding](https://angular.io/guide/interpolation) within the [*ngFor](https://angular.io/api/common/NgForOf) repeater to insert the current iteration's `hero.id` into each [routerLink](https://angular.io/tutorial/toh-pt5#routerlink).

<br>

#### `HeroComponent hero links` 

<br>

- The hero items in the `HeroComponent` are `<li>` elements whose click events are bound to the component's `onSelect()` method.

~~~
[heros.component.html]

<ul class="heroes">
  <li *ngFor="let hero of heroes">
    <button type="button" (click)="onSelect(hero)" [class.selected]="hero === selectedHero">
      <span class="badge">{{hero.id}}</span>
      <span class="name">{{hero.name}}</span>
    </button>
  </li>
</ul>
~~~

- Strip the `<li>` back to just its [*ngFor](https://angular.io/api/common/NgForOf), wrap the badge and name in an anchor (`<a>`) element, and add a [routerLink]() attribute to the anchor that is the same as in the dashboard template.

~~~
<ul class="heroes">
  <li *ngFor="let hero of heroes">
    <a routerLink="/detail/{{hero.id}}">
      <span class="badge">{{hero.id}}</span> {{hero.name}}
    </a>
  </li>
</ul>
~~~

- You'll have to fix the private stylesheet (`heroes.component.scss`) to make the list look as it did before.
- Revised styles are in the [final code review](https://angular.io/tutorial/toh-pt5#heroescomponent) at the bottom of this guide.

<br>

##### Remove dead code (optional)

<br>

- While the `HeroesComponent` class still works, the `onSelect()` method and `selectedHero` property are no longer used.
- It's nice to tidy up and you'll be greteful to yourself later.
- Here's the class after pruning away the dead code.

~~~
[heroes.component.ts]

expor class HeroesComponent implements OnInit {
  heroes: Hero[] = [];

  constructor(
    private heroService: HeroService,
  ){}

  ngOnInit(): void {
    this.getHeroes();
  }

  getHeroes(): void {
    this.heroService.getHeroes()
      .subscribe(heros => this.heroes = heroes);
  }
}
~~~

<br>
<hr>

### Routable HeroDetailComponent

<br>

- Previously, the parent `HeroesComponent` set the `HeroDetailComponent.hero` property and the `HeroDetailCOmponent` displayed the hero.
- `HeroesComponent` doesn't do that anymore. 
- Now the router create the `HeroDetailComponent` in response to a URL such as `~/detail/11`.
- The `HeroDetailComponent` needs a new way to obtain the hero-to-display.
- This section explains the following:
  - Get the route that created it
  - Extract the `id` from the route
  - Acquire the hero with that `id` from the server using the HeroService.
- Add the following imports:

~~~
[hero-detail.component.ts]

import { ActivatedRoute } from '@angular/router';
import { Location } from '@angular/common';

import { HeroService } from './src/app/services/hero/hero.service.ts';
~~~

- Inject the [ActivatedRoute](https://angular.io/api/router/ActivatedRoute), `HeroService`, and [Location](https://angular.io/api/common/Location) services into the constructor, saving their values in private fields.

~~~
[hero-detail.component.ts]

constructor({
  private route: ActivatedRoute,
  private heroService: HeroService,
  private location: Location,
}) {}
~~~

- The [ActivatedRoute](https://angular.io/api/router/ActivatedRoute) holds information about the route to this instance of the `HeroDetailComponent`.
- This component is interested in the route's parameters extracted from the URL.
- The "id" parameter is the `id` of the hero to display.
- The [HeroService](https://angular.io/tutorial/toh-pt4) gets hero data from the remote server and this component will use it to get the hero-to-display.
- The [Location](https://angular.io/api/common/Location) is an Angular service for interacting with the browser. You'll use it [later](https://angular.io/tutorial/toh-pt5#goback) to navigate back to the view that navigated here.

<br>

#### `Extract the id route parameter`

- In the `ngOnInit()` [lifecycle hook](https://angular.io/guide/lifecycle-hooks#oninit) call `getHero()` and define it as follows.


~~~
[hero-detail.component.ts]

ngOnInit(): void {
  this.getHero();
}

getHero(): void {
  const id = Number(this.router.snapshot.paramMap.get('id'));
  this.heroService.getHero(id)
    .subscribe(hero => this.hero = hero);
}
~~~

- The `route.snapshot` is a static image of the route information shortly after the component was created.
- The `paramMap` is a dictionary of route parameter values extracted from the URL.
- The `"id"` key return the `id` of the hero to fetch.
- Route parameters are always strings. The javaScript `Number` function converts the string to a number, which is what a hero `id` should be.
- The browser refreshes and the application crashes with a compiler error.
- `HeroService` doesn't have a `getHero()` method. Add it now.


<br>

#### `Add HeroService.getHero()`

<br>

- Open `HeroService` and add the following `getHero()` method with the `id` after the `getHeroes()` method:

~~~
[hero.service.ts]

getHero(id: number): Observable<Hero> {
  // For now, assume that a hero with the specified 'id' always exists.
  // Error handling will be added in the next step of the tutorial.
  const hero = HEROES.find(h => h.id === id)!;
  this.messageService.add(`HeroService: fetched hero id=${id}`);
  return of(hero);
}
~~~

~~~
IMPORTANT!
 
The backtick(`) characters define a JavaScript [template literal] for embedding the `id`.
~~~

- Like [getHeroes()](), `getHero()`has an asynchronous signature.
- It returns a `mock hero` as an `Observable`, using the RxJS `of()` function.
- You'll be able to re-implement `getHero()` as a real `Http` request without having to change the `HeroDetailComponent` that call it.

<br>

#### `Try it`

- The browser refreshes and the application is working again.
- You can click a hero in the dashboard or in the heroes list and navigate to that hero's detail view.
- If you paste `localhost:4200/detail/11` in the browser address bar, the router navigates to the detail view for the hero with `id: 11`, "Dr.Nice".

<br>

#### `Find the way back`

<br>

- By clicking the browser's back button, you can go back to the hero list or dashboard view, depending upon which sent you to the detail view.
- It would be nice to have a button on the `HeroDetail` view that can do that.
- Add a `go back` button to the bottom of the component template and bind it to the component's `goBack()` method.

~~~
[hero-detail.component.html]

<button type="button" (click)="goBack()">go back</button>
~~~

- Add a `goBack()` method to the component class that navigates backward one step in the browser's history stack using the [Location](https://angular.io/api/common/Location) service that you [injected previously](https://angular.io/tutorial/toh-pt5#hero-detail-ctor).

~~~
goBack(): void {
  this.location.back();
}
~~~

- Refresh the browser and start clicking.
- Users can navigate around the app, from the dashboard to hero details and back, from heroes list to the mini detail to the hero details and back to the heroes again.
- The details will look better when you add the private CSS styles to `hero-detail.component.css` as listed in one of the ["final code review"](https://angular.io/tutorial/toh-pt5#final-code-review) tabs below.

<br>
<hr>

### Summary

<br>

- You added the Angular router to navigate among different components.
- You turned the `AppComponent` into a navigation shell with `<a>` links and a [<router-outlet>](https://angular.io/api/router/RouterOutlet).
- You configured the router in an `AppRoutingModule`.
- You defined routes, a redirect route, and a parameterized route.
- You used the [routerLink]() directive in anchor elements.
- You refactored a tighly-couple master/deetail view into a routed detail view.
- You used router link parameters to navigate to the detail view of a user-selected hero.
- You shared the `HeroService` among multiple components.

<br>
<hr>

## ` 6 - Get data from a server`

- In this tutorial, you'll add the following data persistence features with help from Angular's [HttpClient](https://angular.io/api/common/http/HttpClient)
  - The `HeroService` get hero data with HTTP requests
  - Users can add, edit, and delete heroes and save these changes over HTTP.
  - Users can search for heroes by name.

<br>
<hr>

### Enable HTTP services

<br>

- [HttpClient](https://angular.io/api/common/http/HttpClient) is Angular's mechanism for communicating with a remote server over HTTP.
- Make [HttpClient](https://angular.io/api/common/http/HttpClient) available everywhere in the application in two steps.
- First, add it to the root `AppModule` by importing it.

~~~
import { HttpClientModule } from '@angular/common/http';
~~~

- Next, still in `AppModule`, add [HttpClientModule](https://angular.io/api/common/http/HttpClientModule) to the `imports` array.

~~~
@NgModule({
  imports: [
    HttpClientModule,
  ],
})
~~~

<br>
<hr>

### Simulate data server

<br>

- This tutorial sample mimics communication with a remote data server by using the [in-memory Web API](https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api) module.
- After installing the module, the application will make requests to and receive responses from the [HttpClient](https://angular.io/api/common/http/HttpClient) without knowing that the `in-memory Web API` is intercepting those requests, applying them to an in-memory data store, and returning simulated responses.
- By using the `in-memory Web API`, you won't have to set up a server to learn about [HttpClient](https://angular.io/api/common/http/HttpClient).

> IMPORTANT
> >
> The in-memory Web API module has nothing to do with HTTP in Angular.
> >
> If you're reading this tutoria to learn about [HttpClient](https://angular.io/api/common/http/HttpClient), you can [skip over](https://angular.io/tutorial/toh-pt6#import-heroes) this step. If you're coding along with this tutorial, stay here and add the in-memory Web API now.

- Install the in-memory Web API package from nom with the following command:

~~~
npm install angular-in-memory-web-api --save
~~~

- In the `AppModule`, import the `HttpClientInMemoryWebApiModule` and the `InMemoryDataService` class, which you will create in a moment.

~~~
import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
import { InMemoryDataService } from './src/app/services/in-memory-datain-memory-data.service';
~~~

- After the [HttpClientModule](), add the `HttpClientInMemoryWebApiModule` to the `AppModule` `imports` array and configure it with the `InMemoryDataService`.

~~~
[app.module.ts]

HttpClientModule,

// The HttpClientInMemoryWebApiModule module intercepts HTTP requests and returns simulated server responses.
// Remove it when a real server is ready to receive requests.
HttpClientInMemoryWebApiModule.forRoot(
  InMemoryDataService,
  { dataEncapsulation: false},
)
~~~

- The `forRoot()` configuration method takes an `InMemoryDataService` class that primes the in-memory database.
- Generate the class `/src/app/service/in-memory-data/in-memory-data.service.ts` with the following command:

~~~
ng g service InMemoryData
~~~

- Replace the default contents of `in-memory-data.service.ts` with the following:

~~~
import { Injectable } from '@Angular/core';
import { InMemoryDbService } from 'angular-in-memory-web-api';
import { Hero } from './src/app/interfaces/hero.ts

@Injectable({
  providedIn: 'root',
})

export class InMemoryDataService implements InMemoryDbService {
  createDb(){
    const heroes = [
      { id: 12, name: 'Dr. Nice' },
      { id: 13, name: 'Bombasto' },
      { id: 14, name: 'Celeritas' },
      { id: 15, name: 'Magneta' },
      { id: 16, name: 'RubberMan' },
      { id: 17, name: 'Dynama' },
      { id: 18, name: 'Dr. IQ' },
      { id: 19, name: 'Magma' },
      { id: 20, name: 'Tornado' }
    ];
    return {heroes};
  }

  // Overrides the genId method to ensure that a hero always has an id.
  // If the heroes array is empty, the method below returns the initial number (11).
  // If the heroes array is not empty, the method below returns the highest hero id + 1.
  genId(heroes: Hero[]): number {
    return heroes.length > 0 ? Math.max(...heroes.map(hero => hero.id)) + 1 : 11;
  }
}
~~~

- The `in-memory-data.service.ts` file will take over the function of `mock-heroes.ts`.
- However, don't delete `mock-heroes.ts` yet, as you still need it for a few more steps of this tutorial.
- When the server is ready, you'll detach the In-memory Web API, and the application's requests will go through to the server.

<br>
<hr>

### Heroes and HTTP

<br>

- In the `HeroService`, import [HttpClient](https://angular.io/api/common/http/HttpClient) and [HttpHeaders](https://angular.io/api/common/http/HttpHeaders):

~~~
[hero.service.ts]

import { HttpClient, HttpHeaders } from '@angular/common/http';
~~~

- Still in the `HeroService`, inject [HttpClient](https://angular.io/api/common/http/HttpClient) into the constructor in a private property called [http](https://angular.io/api/common/http).

~~~
constructor({
  private http: HttpClient,
  private messageService: MessageService,
})
~~~

- Notice that you keep injecting the `MessageService` but since you'll call it so frequently, wrap it in a private `logig()` method:

~~~
/** Log a HeroService message with the MessageService */
private log(message: string){
  this.messageService.add(`HeroService: ${message}`);
}
~~~

- Define the `HeroesUrl` of the form `:base/:collectionName` with the address of the heroes resource on the server.
- Here `base` is the resource to which requests are made, and `collectionName` is the heroes data object in the `in-memory-data.service.ts`.

~~~
private heroesURL = 'api/heroes'; // URL to web api
~~~

<br>

#### `Get heroes with `[HttpClient](https://angular.io/api/common/http/HttpClient)

<br>

- The current `HeroService.getHeroes()` uses the RxJS `of()` function to return an array of mock heroes as an `Observable<Hero[]>`

~~~
[hero.service.ts](getHeroes with RxJS'of()')

getHeroes(): Observable<Hero[]> {
  const heroes = of(HEROES);
  return heroes;
}
~~~

- Convert that method to use [HttpClient](https://angular.io/api/common/http/HttpClient) as follows:

~~~
/** GET heroes from the server */
getHeroes(): Observable<Hero[]>{
  return this.http.get<Hero[]>(this.heroesUrl)
}
~~~

- Refresh the browser.
- The hero data should successfully load from the mock server.
- You've swapped `of()` for `http.get()` and the application keeps working without any other changes because both functions return an `Observable<Hero[]>`

<br>

#### [HttpClient](https://angular.io/api/common/http/HttpClient) `methods return one value`

<br>

- All [HttpClient]() methods return an RxJS `Observable` of something.
- HTTP is a request/response protocol.
- You make a request, it returns a single response.
- In general, an observable `can return` multiple values over time.
- An observable from [HttpClient](https://angular.io/api/common/http/HttpClient) always emits a single value and the completes, never to emit again.
- This particular [HttpClient.get()]() call returns an `Observable<Hero[]>`; that is, "`an observable of hero arrays`".
- In practive, it will only return a single hero array.

<br>

#### [HttpClient.get()]() `returns response data`

<br>













































